<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LoggerUtilities.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">auto-complete-service</a> &gt; <a href="index.source.html" class="el_package">com.ac.util</a> &gt; <span class="el_source">LoggerUtilities.java</span></div><h1>LoggerUtilities.java</h1><pre class="source lang-java linenums">package com.ac.util;

import java.text.MessageFormat;

import org.owasp.encoder.Encode;

/**
 * Utility methods for constructing messages for application logs.
 *
 * @author sarvesh
 */
public final class LoggerUtilities {

    /**
     * Added to hide the default public constructor.
     */
<span class="nc" id="L17">    private LoggerUtilities() {</span>
<span class="nc" id="L18">        throw new AssertionError();</span>
    }

    /**
     * Empty string replacement.
     */
    private static final String EMPTY = &quot;&quot;;

    /**
     * Returns a formatted message string based on the supplied format and
     * parameters. The format and the parameters will be cleansed by replacing the
     * CR and LF characters with the Java strings &quot;\\r&quot; and &quot;\\n&quot;. The parameters
     * are merged within the messages format through the MessageFormat class.
     *
     * @see MessageFormat
     * @param messageFormat the message pattern with place holders; both indexed and
     *                      non-indexed place holders are accepted. Examples:
     *                      &quot;Message first text. Message second text {0} {1}&quot;
     *                      &quot;Message first text. Message second text {} {}&quot;
     * @param formatParams  the formatting arguments. If the message is fixed text
     *                      and doesn't have place holders, formatParams shall be
     *                      null or empty array.
     * @return formatted message string
     */
    public static String getMessage(final String messageFormat, final Object... formatParams) {
<span class="pc bpc" id="L43" title="2 of 4 branches missed.">        if (messageFormat != null &amp;&amp; !messageFormat.isEmpty()) {</span>
<span class="fc" id="L44">            final Object[] params = sanitiseParams(false, formatParams);</span>
<span class="fc" id="L45">            String cleanMsg = Encode.forJava(MessageFormat.format(getFormat(true, messageFormat), params));</span>
<span class="pc bpc" id="L46" title="1 of 2 branches missed.">            if (cleanMsg.contains(&quot;\&quot;&quot;)) {</span>
                // preserve the double quotes
<span class="nc" id="L48">                cleanMsg = cleanMsg.replace(&quot;\\\&quot;&quot;, &quot;\&quot;&quot;);</span>
            }
<span class="fc" id="L50">            return cleanMsg;</span>
        } else {
<span class="nc" id="L52">            return LoggerUtilities.EMPTY;</span>
        }
    }

    /**
     * Prepares the parameters for inserting in the message template. Optionally
     * could apply OWASP Encoder for Java to replace the CR and the LF characters by
     * the Java strings &quot;\\r&quot; and &quot;\\n&quot;.
     *
     * @param cleanCRLF    - if true will call Encoder. Encoder shall not be called
     *                     if the entire message is being cleansed.
     * @param formatParams params to sanitise
     * @return cleansed versions of params.
     */
    private static Object[] sanitiseParams(boolean cleanCRLF, final Object... formatParams) {
<span class="pc bpc" id="L67" title="1 of 2 branches missed.">        final int numParams = formatParams == null ? 0 : formatParams.length;</span>
<span class="fc" id="L68">        final String[] sanitisedParams = new String[numParams];</span>

<span class="fc bfc" id="L70" title="All 2 branches covered.">        for (int i = 0; i &lt; numParams; i++) {</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">            sanitisedParams[i] = (formatParams[i] == null ? EMPTY : formatParams[i].toString());</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">            if (cleanCRLF) {</span>
<span class="nc" id="L73">                sanitisedParams[i] = Encode.forJava(sanitisedParams[i]);</span>
            }
        }

<span class="fc" id="L77">        return sanitisedParams;</span>
    }

    /**
     * Replaces all occurrences of &quot;{}&quot; with &quot;{0}&quot;, &quot;{1}&quot;, etc. so that the text can
     * be message pattern compliant to MessageFormat.format. The method doesn't
     * apply CRLF cleaning. DO NOT use the method outside of the class, its
     * package-visible only for the sake of the unit testing.
     *
     * @see MessageFormat
     * @param addIndexes if place holders shall be indexed or not;
     * @param format     string to update
     * @return updated string
     */
    private static String getFormat(boolean addIndexes, final String format) {
<span class="fc" id="L92">        String result = format;</span>
<span class="pc bpc" id="L93" title="1 of 2 branches missed.">        if (!addIndexes) {</span>
<span class="nc" id="L94">            return result;</span>
        }

<span class="fc" id="L97">        int i = 0;</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        while (result.contains(&quot;{}&quot;)) {</span>
<span class="fc" id="L99">            String replacement = &quot;{&quot; + i++ + &quot;}&quot;;</span>
<span class="pc bpc" id="L100" title="1 of 2 branches missed.">            if (!result.contains(replacement)) {</span>
<span class="fc" id="L101">                result = result.replaceFirst(&quot;\\{\\}&quot;, replacement);</span>
            }
<span class="fc" id="L103">        }</span>
<span class="fc" id="L104">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>